#include "background_sub.h"

using namespace std;

//global variables
Mat fgMaskMOG; //fg mask generated by MOG method
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Ptr<BackgroundSubtractor> pMOG; //MOG Background subtractor
Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
int keyboard;


Mat background_sub(Mat background, Mat frame)
{
	namedWindow("Frame", 1);
	namedWindow("FG Mask MOG", 1);
	namedWindow("FG Mask MOG 2", 1);
	namedWindow("Masked image", 1);
	pMOG = new BackgroundSubtractorMOG(); //MOG approach
	pMOG2 = new BackgroundSubtractorMOG2(); //MOG2 approach
	pMOG->operator()(background, fgMaskMOG);
	pMOG2->operator()(background, fgMaskMOG2);
	imshow("Frame", background);
	imshow("FG Mask MOG", fgMaskMOG);
	imshow("FG Mask MOG 2", fgMaskMOG2);
	pMOG->operator()(frame, fgMaskMOG);
	pMOG2->operator()(frame, fgMaskMOG2);
	fgMaskMOG2 = dilation(fgMaskMOG2);
	Mat dest;
	frame.copyTo(dest);
	for (int i = 0; i < frame.rows; i++)
	{
		for (int j = 0; j < frame.cols; j++)
		{
			int color = (int)fgMaskMOG2.at<uchar>(Point(j, i));
			if (color <= 127)
			{
				dest.at<uchar>(Point(j * 3, i)) = 127;
				dest.at<uchar>(Point((j * 3) + 1, i)) = 127;
				dest.at<uchar>(Point((j * 3) + 2, i)) = 127;
			}
		}
	}
	imwrite("fgmask.jpg", fgMaskMOG2);
	imwrite("dest.png", dest);
	namedWindow("Source", 1);
	imshow("Frame", frame);
	imshow("FG Mask MOG", fgMaskMOG);
	imshow("FG Mask MOG 2", fgMaskMOG2);
	imshow("Masked image", dest);
	imshow("Source", background);
	return dest;
}

Mat dilation(Mat src)
{
	Mat dilation_dst;
	namedWindow("Dilation Demo", CV_WINDOW_AUTOSIZE);
	cvMoveWindow("Dilation Demo", src.cols, 0);

	int dilation_elem = 1;
	int dilation_size = 1;
	int dilation_type = MORPH_RECT;

	Mat element = getStructuringElement(dilation_type,
		Size(2 * dilation_size + 1, 2 * dilation_size + 1),
		Point(dilation_size, dilation_size));
	dilate(src, dilation_dst, element);
	imshow("Dilation Demo", dilation_dst);
	return dilation_dst;
}

/*void processVideo(char* videoFilename) {
	//create the capture object
	VideoCapture capture(videoFilename);
	if (!capture.isOpened()) {
		//error in opening the video input
		cerr << "Unable to open video file: " << videoFilename << endl;
		exit(EXIT_FAILURE);
	}
	//read input data. ESC or 'q' for quitting
	while ((char)keyboard != 'q' && (char)keyboard != 27) {
		//read the current frame
		if (!capture.read(frame)) {
			cerr << "Unable to read next frame." << endl;
			cerr << "Exiting..." << endl;
			exit(EXIT_FAILURE);
		}
		//update the background model
		//AND HERE!!!
		pMOG->operator()(frame, fgMaskMOG);
		pMOG2->operator()(frame, fgMaskMOG2);
		//get the frame number and write it on the current frame
		stringstream ss;
		rectangle(frame, cv::Point(10, 2), cv::Point(100, 20),
			cv::Scalar(255, 255, 255), -1);
		ss << capture.get(CV_CAP_PROP_POS_FRAMES);
		string frameNumberString = ss.str();
		putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
			FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 0, 0));
		//show the current frame and the fg masks
		imshow("Frame", frame);
		imshow("FG Mask MOG", fgMaskMOG);
		imshow("FG Mask MOG 2", fgMaskMOG2);
		//get the input from the keyboard
		keyboard = waitKey(30);
	}
	//delete capture object
	capture.release();
}*/

